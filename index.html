<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC SFU - Audio Room</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .form-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: bold;
        }
        input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            box-sizing: border-box;
        }
        button {
            width: 100%;
            padding: 12px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #leaveBtn {
            background-color: #f44336;
        }
        #leaveBtn:hover {
            background-color: #da190b;
        }
        .status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            background-color: #e3f2fd;
            border-left: 4px solid #2196F3;
        }
        .status.connected {
            background-color: #e8f5e9;
            border-left-color: #4CAF50;
        }
        .status.error {
            background-color: #ffebee;
            border-left-color: #f44336;
        }
        #audioContainer {
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>WebRTC SFU - Audio Room</h1>

        <div id="joinForm">
            <div class="form-group">
                <label for="name">Your Name:</label>
                <input type="text" id="name" placeholder="Enter your name">
            </div>

            <div class="form-group">
                <label for="roomId">Room Code:</label>
                <input type="text" id="roomId" placeholder="Enter room code">
            </div>

            <button id="joinBtn">Join Room</button>
        </div>

        <div id="roomControls" style="display: none;">
            <button id="leaveBtn">Leave Room</button>
        </div>

        <div id="status"></div>
        <div id="audioContainer"></div>
    </div>

    <script>
        let ws = null;
        let peerConnection = null;
        let localStream = null;

        const joinBtn = document.getElementById('joinBtn');
        const leaveBtn = document.getElementById('leaveBtn');
        const nameInput = document.getElementById('name');
        const roomIdInput = document.getElementById('roomId');
        const joinForm = document.getElementById('joinForm');
        const roomControls = document.getElementById('roomControls');
        const statusDiv = document.getElementById('status');
        const audioContainer = document.getElementById('audioContainer');

        const config = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' }
            ]
        };

        function updateStatus(message, type = 'info') {
            statusDiv.textContent = message;
            statusDiv.className = 'status ' + type;
        }

        async function joinRoom() {
            const name = nameInput.value.trim();
            const roomId = roomIdInput.value.trim();

            if (!name || !roomId) {
                alert('Please fill in your name and room code');
                return;
            }

            try {
                updateStatus('Connecting to server...', 'info');

                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                ws = new WebSocket(`${protocol}//${window.location.host}/ws`);

                ws.onopen = async () => {
                    updateStatus('Getting microphone access...', 'info');

                    localStream = await navigator.mediaDevices.getUserMedia({
                        audio: true,
                        video: false
                    });

                    peerConnection = new RTCPeerConnection(config);

                    localStream.getTracks().forEach(track => {
                        peerConnection.addTrack(track, localStream);
                    });

                    peerConnection.ontrack = (event) => {
                        const track = event.track;
                        const stream = event.streams[0];
                        console.log('Track received:', track.id, 'kind:', track.kind);

                        const audio = document.createElement('audio');
                        audio.srcObject = stream;
                        audio.autoplay = true;
                        audio.id = 'audio-' + track.id;

                        audio.onplaying = () => {
                            console.log('Audio playing:', track.id);
                        };
                        audio.onerror = (e) => {
                            console.error('Audio error:', track.id, e);
                        };

                        audioContainer.appendChild(audio);
                    };

                    peerConnection.onicecandidate = (event) => {
                        if (event.candidate) {
                            ws.send(JSON.stringify({
                                type: 'candidate',
                                data: JSON.stringify(event.candidate)
                            }));
                        }
                    };

                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);

                    ws.send(JSON.stringify({
                        type: 'join',
                        data: JSON.stringify({ name, roomId })
                    }));
                };

                ws.onmessage = async (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        console.log('Message received:', message.type);

                        switch (message.type) {
                            case 'joined':
                                updateStatus(`Connected to room ${roomId}`, 'connected');
                                joinForm.style.display = 'none';
                                roomControls.style.display = 'block';

                                console.log('Sending initial offer');
                                const offer = peerConnection.localDescription;
                                ws.send(JSON.stringify({
                                    type: 'offer',
                                    data: JSON.stringify(offer)
                                }));
                                break;

                            case 'answer':
                                console.log('Processing answer...');
                                const answer = JSON.parse(message.data);
                                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                                console.log('Answer processed successfully');
                                break;

                            case 'offer':
                                console.log('Received renegotiation offer');
                                console.log('Connection state:', peerConnection.connectionState);
                                console.log('Signaling state:', peerConnection.signalingState);

                                const remoteOffer = JSON.parse(message.data);

                                if (peerConnection.signalingState !== 'stable') {
                                    console.log('Connection not stable, performing rollback...');
                                    await peerConnection.setLocalDescription({type: 'rollback'});
                                }

                                console.log('Setting remote description...');
                                await peerConnection.setRemoteDescription(new RTCSessionDescription(remoteOffer));

                                console.log('Creating answer...');
                                const answerDesc = await peerConnection.createAnswer();

                                console.log('Setting local description...');
                                await peerConnection.setLocalDescription(answerDesc);

                                console.log('Sending renegotiation answer...');
                                ws.send(JSON.stringify({
                                    type: 'answer',
                                    data: JSON.stringify(answerDesc)
                                }));
                                console.log('Answer sent successfully');
                                break;

                            case 'candidate':
                                const candidate = JSON.parse(message.data);
                                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                                break;

                            case 'peer-joined':
                                console.log('Peer joined:', message.data);
                                updateStatus(`${message.data} joined the room`, 'connected');
                                break;

                            default:
                                console.warn('Unknown message type:', message.type);
                        }
                    } catch (error) {
                        console.error('ERROR processing message:', error);
                        console.error('Stack trace:', error.stack);
                    }
                };

                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateStatus('Connection error', 'error');
                };

                ws.onclose = () => {
                    updateStatus('Disconnected', 'error');
                    cleanup();
                };

            } catch (error) {
                console.error('Error joining room:', error);
                updateStatus('Error joining room: ' + error.message, 'error');
            }
        }

        function leaveRoom() {
            cleanup();
            joinForm.style.display = 'block';
            roomControls.style.display = 'none';
            updateStatus('', 'info');
        }

        function cleanup() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }

            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            if (ws) {
                ws.close();
                ws = null;
            }

            audioContainer.innerHTML = '';
        }

        joinBtn.addEventListener('click', joinRoom);
        leaveBtn.addEventListener('click', leaveRoom);

        window.addEventListener('beforeunload', cleanup);
    </script>
</body>
</html>
